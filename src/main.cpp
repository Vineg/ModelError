#include <memory>
#include <vector>
#include <fstream>
#include <iostream>
#include <cstring>
#include <cmath>
#include <limits>
#include <algorithm>

#include "tinyply.h"
#include "Point.h"
#include "Box.h"
#include "Face.h"
#include "Node.h"
#include "PlyFileData.h"


using namespace std;
using tinyply::PlyData;
using tinyply::Type;
using tinyply::PlyFile;

shared_ptr<PlyFileData> read_ply_file(const string & filepath)
{
    auto result = make_shared<PlyFileData>();

    unique_ptr<istream> file_stream;
    vector<uint8_t> byte_buffer;

    try
    {

        file_stream.reset(new ifstream(filepath, ios::binary));

        if (!file_stream || file_stream->fail()) throw runtime_error("failed to open " + filepath);

        PlyFile file;
        file.parse_header(*file_stream);

        shared_ptr<PlyData> vertices, normals, faces, texcoords;

        try { vertices = file.request_properties_from_element("vertex", { "x", "y", "z" }); }
        catch (const exception & e) { cerr << "tinyply exception: " << e.what() << endl; }

        try { faces = file.request_properties_from_element("face", { "vertex_indices" }, 3); }
        catch (const exception & e) { cerr << "tinyply exception: " << e.what() << endl; }

        file.read(*file_stream);

        {
            std::vector<float3> verts(vertices->count);
            const size_t numVerticesBytes = vertices->buffer.size_bytes();
            memcpy(verts.data(), vertices->buffer.get(), numVerticesBytes);
            result->vertices = std::vector<double3>(verts.begin(), verts.end());

            result->faces = std::vector<uint3>(faces->count);
            const size_t numFacesBytes = faces->buffer.size_bytes();
            memcpy(result->faces.data(), faces->buffer.get(), numFacesBytes);

            result->triangles = vector<Face>();

            for (auto face : result->faces) {
                result->triangles.push_back(Face({
                    &result->vertices[face.x],
                    &result->vertices[face.y],
                    &result->vertices[face.z]
                }));
            }
        }
        return result;
    }
    catch (const exception & e)
    {
        cerr << "Caught tinyply exception: " << e.what() << endl;
        return shared_ptr<PlyFileData>();
    }
}

void write_ply_model(const string & filePath, shared_ptr<geometry> model)
{

    filebuf fb_binary;
    fb_binary.open(filePath, ios::out | ios::binary);
    ostream outstream_binary(&fb_binary);
    if (outstream_binary.fail()) throw runtime_error("failed to open " + filePath);

    PlyFile model_file;

    vector<float3> verts(model->vertices.begin(), model->vertices.end());
    model_file.add_properties_to_element("vertex", {"x", "y", "z" },
                                         Type::FLOAT32, verts.size(), reinterpret_cast<uint8_t*>(verts.data()), Type::INVALID, 0);

    if (!model->colors.empty()) {
        model_file.add_properties_to_element("vertex", {"red", "green", "blue"},
                                             Type::UINT8, model->colors.size(),
                                             reinterpret_cast<uint8_t *>(model->colors.data()), Type::INVALID, 0);
    }
    model_file.add_properties_to_element("face", {"vertex_indices" },
                                         Type::UINT32, model->faces.size(), reinterpret_cast<uint8_t*>(model->faces.data()), Type::UINT8, 3);

    model_file.get_comments().push_back("generated by tinyply 2.2");

    model_file.write(outstream_binary, true);
}

int main(int argc, char *argv[])
{
    if (argc < 4) {
        cout << "usage: " << endl  << "ModelError" << " actualModel.ply expectedModel.ply out.ply";
        return EXIT_SUCCESS;
    }
    shared_ptr<PlyFileData> fine_model = read_ply_file(argv[1]);
    shared_ptr<PlyFileData> coarse_model = read_ply_file(argv[2]);
    char* out_path = argv[3];
    auto box2 = Box({0.0, 0.0, 0.0}, {1.0, 1.0, 1.0});
    auto inf_double = numeric_limits<double>::infinity();
    double3 min = {inf_double, inf_double, inf_double};
    double3 max = {-inf_double, -inf_double, -inf_double};
    for (auto & vert : coarse_model->vertices) {
        min = min.min(vert);
        max = max.max(vert);
    }

    auto coarse_extents = Box(min, max);
    auto n1 = make_shared<Node<Face>>(coarse_extents);
    cout << "building tree" << flush;
    double average_triangle_size = 0;
    for (uint i = 0; i < coarse_model->triangles.size(); i++) {
        Face &triangle = coarse_model->triangles[i];
        average_triangle_size += triangle.bounds().maxWidth();
        n1->put(make_shared<Face>(triangle));
        if ((i % (coarse_model->triangles.size() / 10 + 1)) == 0) {
            cout << "." << flush;
        }
    }
    cout << endl;
    average_triangle_size /= coarse_model->triangles.size();

    //reduce query radius to have smaller results
    double radius_reduce = 16;
    double start_query_radius = average_triangle_size / radius_reduce;
    double3 e = {1, 1, 1};

    vector<shared_ptr<Face>> query_result{};
    auto query_box = make_shared<Box>(min, max);
    int totalFetched = 0;
    const unsigned long vertices_count = fine_model->vertices.size();
    vector<double> distances(vertices_count);
    auto DOUBLE_INFINITY = numeric_limits<double>::infinity();
    double maxDist = -DOUBLE_INFINITY;
    double total_dist = 0;
    cout << "calculating" << flush;
    for (uint i = 0; i < vertices_count; i++) {
        double3 vert = fine_model->vertices[i];
        double dist = DOUBLE_INFINITY;
        double query_radius = start_query_radius;
        while (dist > query_radius) {
            const double3 &query_vec = e * query_radius;
            query_box->start = vert - query_vec;
            query_box->end = vert + query_vec;

            n1->query(*query_box, query_result);

            for (auto &result_shape : query_result) {
                dist = std::min(dist, result_shape->dist(vert));
            }
            totalFetched += query_result.size();

            query_result.resize(0);

            query_radius *= 1.5;
        }
        distances[i] = dist;
        total_dist += dist;
        if (dist > maxDist) {
            maxDist = dist;
        }
        if ((i % (vertices_count / 10 + 1)) == 0) {
            cout << "." << flush;
        }
    }
    cout << endl;

    double average_dist = total_dist / vertices_count;
    for (uint i = 0; i < vertices_count; ++i) {
        fine_model->colors.push_back(jet_color(std::min(1.0, distances[i] / (average_dist * 5.0))));
    }

    write_ply_model(out_path, fine_model);

    n1.reset();
    coarse_model.reset();
    cout << "average query result: " << (totalFetched / vertices_count) << endl;
    return EXIT_SUCCESS;
}
