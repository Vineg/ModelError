#include <memory>
#include <vector>
#include <fstream>
#include <iostream>
#include <cstring>
#include <cmath>
#include <limits>

#include "tinyply.h"
#include "Point.h"
#include "Box.h"
#include "Face.h"
#include "Node.h"
#include "PlyFileData.h"

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif M_PI


#define TINYPLY_IMPLEMENTATION true

using namespace std;
using tinyply::PlyData;
using tinyply::Type;
using tinyply::PlyFile;

//struct double3 { double x, y, z; };

shared_ptr<PlyFileData> read_ply_file(const string & filepath)
{
    auto result = make_shared<PlyFileData>();

    unique_ptr<istream> file_stream;
    vector<uint8_t> byte_buffer;

    try
    {

        file_stream.reset(new ifstream(filepath, ios::binary));

        if (!file_stream || file_stream->fail()) throw runtime_error("failed to open " + filepath);

        PlyFile file;
        file.parse_header(*file_stream);

        shared_ptr<PlyData> vertices, normals, faces, texcoords;
        // The header information can be used to programmatically extract properties on elements
        // known to exist in the header prior to reading the data. For brevity of this sample, properties
        // like vertex position are hard-coded:
        try { vertices = file.request_properties_from_element("vertex", { "x", "y", "z" }); }
        catch (const exception & e) { cerr << "tinyply exception: " << e.what() << endl; }

        // Providing a list size hint (the last argument) is a 2x performance improvement. If you have
        // arbitrary ply files, it is best to leave this 0.
        try { faces = file.request_properties_from_element("face", { "vertex_indices" }, 3); }
        catch (const exception & e) { cerr << "tinyply exception: " << e.what() << endl; }

        file.read(*file_stream);

        // type casting to your own native types - Option A
        {
            std::vector<float3> verts(vertices->count);
            const size_t numVerticesBytes = vertices->buffer.size_bytes();
            memcpy(verts.data(), vertices->buffer.get(), numVerticesBytes);
            result->vertices = std::vector<double3>(verts.begin(), verts.end());

            result->faces = std::vector<uint3>(faces->count);
            const size_t numFacesBytes = faces->buffer.size_bytes();
            memcpy(result->faces.data(), faces->buffer.get(), numFacesBytes);

            result->triangles = vector<Face>();

            for (auto face : result->faces) {
                result->triangles.push_back(Face({
                    &result->vertices[face.x],
                    &result->vertices[face.y],
                    &result->vertices[face.z]
                }));
            }
        }
        return result;
    }
    catch (const exception & e)
    {
        cerr << "Caught tinyply exception: " << e.what() << endl;
        return shared_ptr<PlyFileData>();
    }
}

void write_ply_model(const string & filePath, shared_ptr<geometry> model)
{

    filebuf fb_binary;
    fb_binary.open(filePath, ios::out | ios::binary);
    ostream outstream_binary(&fb_binary);
    if (outstream_binary.fail()) throw runtime_error("failed to open " + filePath);

    PlyFile model_file;

    vector<float3> verts(model->vertices.begin(), model->vertices.end());
    model_file.add_properties_to_element("vertex", {"x", "y", "z" },
                                         Type::FLOAT32, verts.size(), reinterpret_cast<uint8_t*>(verts.data()), Type::INVALID, 0);

    if (!model->colors.empty()) {
        model_file.add_properties_to_element("vertex", {"red", "green", "blue"},
                                             Type::UINT8, model->colors.size(),
                                             reinterpret_cast<uint8_t *>(model->colors.data()), Type::INVALID, 0);
    }
    model_file.add_properties_to_element("face", {"vertex_indices" },
                                         Type::UINT32, model->faces.size(), reinterpret_cast<uint8_t*>(model->faces.data()), Type::UINT8, 3);

    model_file.get_comments().push_back("generated by tinyply 2.2");

    model_file.write(outstream_binary, true);
}

int main(int argc, char *argv[])
{
    if (argc < 4) {
        cout << "usage: " << endl  << "ModelError" << " realModel.ply expectedModel.ply out.ply";
        return EXIT_SUCCESS;
    }
    shared_ptr<PlyFileData> fine_model = read_ply_file(argv[1]);
    shared_ptr<PlyFileData> coarse_model = read_ply_file(argv[2]);
    char* out_path = argv[3];
    auto box2 = Box(Point({0.0, 0.0, 0.0}), Point({1.0, 1.0, 1.0}));
    auto inf_double = numeric_limits<double>::infinity();
    double3 min = {inf_double, inf_double, inf_double};
    double3 max = {-inf_double, -inf_double, -inf_double};
    for (auto & vert : coarse_model->vertices) {
        min = min.min(vert);
        max = max.max(vert);
    }

    auto coarse_extents = Box(min, max);
    auto n1 = make_shared<Node<Face>>(coarse_extents);
    cout << "building tree" << flush;
    for (uint i = 0; i < coarse_model->triangles.size(); i++) {
        n1->put(make_shared<Face>(coarse_model->triangles[i]));
        if ((i % (coarse_model->triangles.size() / 10 + 1)) == 0) {
            cout << "." << flush;
        }
    }
    cout << endl;

    //reduce query radius to have smaller results
    float radius_reduce = 100.0;
    float start_query_radius = sqrt(M_PI * (max - min).length_sq() / coarse_model->vertices.size()) / radius_reduce;
    double3 e = {1, 1, 1};

    vector<shared_ptr<Face>> query_result{};
    auto query_box = make_shared<Box>(min, max);
    int totalFetched = 0;
    unsigned long vertices_count = fine_model->vertices.size();
    float dists[vertices_count];
    float maxDist = -numeric_limits<float>::infinity();
    float total_dist = 0;
    cout << "calculating" << flush;
    for (uint i = 0; i < vertices_count; i++) {
        double3 vert = fine_model->vertices[i];
        float dist = INFINITY;
        float query_radius = start_query_radius;
        while (dist > query_radius) {
            const double3 &query_vec = e * query_radius;
            query_box->start = vert - query_vec;
            query_box->end = vert + query_vec;

            n1->query(*query_box, query_result);

            for (auto result_shape : query_result) {
                dist = std::min(dist, result_shape->dist(vert));
            }
            totalFetched += query_result.size();

            query_result.resize(0);

            query_radius *= 1.5;
        }
        dists[i] = dist;
        total_dist += dist;
        if (dist > maxDist) {
            maxDist = dist;
        }
        if ((i % (vertices_count / 10 + 1)) == 0) {
            cout << "." << flush;
        }
    }
    cout << endl;

    float average_dist = total_dist / vertices_count;
    for (uint i = 0; i < vertices_count; ++i) {
        fine_model->colors.push_back(jet_color(std::min(1.0f, dists[i] / (average_dist * 5))));
    }

    write_ply_model(out_path, fine_model);

    n1.reset();
    coarse_model.reset();
    cout << "average query result: " << (totalFetched / vertices_count) << endl;
    return EXIT_SUCCESS;
}
